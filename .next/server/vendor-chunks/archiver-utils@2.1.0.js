/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/archiver-utils@2.1.0";
exports.ids = ["vendor-chunks/archiver-utils@2.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\r\nvar fs = __webpack_require__(/*! graceful-fs */ \"(ssr)/./node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\n\r\nvar flatten = __webpack_require__(/*! lodash.flatten */ \"(ssr)/./node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js\");\r\nvar difference = __webpack_require__(/*! lodash.difference */ \"(ssr)/./node_modules/.pnpm/lodash.difference@4.5.0/node_modules/lodash.difference/index.js\");\r\nvar union = __webpack_require__(/*! lodash.union */ \"(ssr)/./node_modules/.pnpm/lodash.union@4.6.0/node_modules/lodash.union/index.js\");\r\nvar isPlainObject = __webpack_require__(/*! lodash.isplainobject */ \"(ssr)/./node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js\");\r\n\r\nvar glob = __webpack_require__(/*! glob */ \"(ssr)/./node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js\");\r\n\r\nvar file = module.exports = {};\r\n\r\nvar pathSeparatorRe = /[\\/\\\\]/g;\r\n\r\n// Process specified wildcard glob patterns or filenames against a\r\n// callback, excluding and uniquing files in the result set.\r\nvar processPatterns = function(patterns, fn) {\r\n  // Filepaths to return.\r\n  var result = [];\r\n  // Iterate over flattened patterns array.\r\n  flatten(patterns).forEach(function(pattern) {\r\n    // If the first character is ! it should be omitted\r\n    var exclusion = pattern.indexOf('!') === 0;\r\n    // If the pattern is an exclusion, remove the !\r\n    if (exclusion) { pattern = pattern.slice(1); }\r\n    // Find all matching files for this pattern.\r\n    var matches = fn(pattern);\r\n    if (exclusion) {\r\n      // If an exclusion, remove matching files.\r\n      result = difference(result, matches);\r\n    } else {\r\n      // Otherwise add matching files.\r\n      result = union(result, matches);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n// True if the file path exists.\r\nfile.exists = function() {\r\n  var filepath = path.join.apply(path, arguments);\r\n  return fs.existsSync(filepath);\r\n};\r\n\r\n// Return an array of all file paths that match the given wildcard patterns.\r\nfile.expand = function(...args) {\r\n  // If the first argument is an options object, save those options to pass\r\n  // into the File.prototype.glob.sync method.\r\n  var options = isPlainObject(args[0]) ? args.shift() : {};\r\n  // Use the first argument if it's an Array, otherwise convert the arguments\r\n  // object to an array and use that.\r\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\r\n  // Return empty set if there are no patterns or filepaths.\r\n  if (patterns.length === 0) { return []; }\r\n  // Return all matching filepaths.\r\n  var matches = processPatterns(patterns, function(pattern) {\r\n    // Find all matching files for this pattern.\r\n    return glob.sync(pattern, options);\r\n  });\r\n  // Filter result set?\r\n  if (options.filter) {\r\n    matches = matches.filter(function(filepath) {\r\n      filepath = path.join(options.cwd || '', filepath);\r\n      try {\r\n        if (typeof options.filter === 'function') {\r\n          return options.filter(filepath);\r\n        } else {\r\n          // If the file is of the right type and exists, this should work.\r\n          return fs.statSync(filepath)[options.filter]();\r\n        }\r\n      } catch(e) {\r\n        // Otherwise, it's probably not the right type.\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return matches;\r\n};\r\n\r\n// Build a multi task \"files\" object dynamically.\r\nfile.expandMapping = function(patterns, destBase, options) {\r\n  options = Object.assign({\r\n    rename: function(destBase, destPath) {\r\n      return path.join(destBase || '', destPath);\r\n    }\r\n  }, options);\r\n  var files = [];\r\n  var fileByDest = {};\r\n  // Find all files matching pattern, using passed-in options.\r\n  file.expand(options, patterns).forEach(function(src) {\r\n    var destPath = src;\r\n    // Flatten?\r\n    if (options.flatten) {\r\n      destPath = path.basename(destPath);\r\n    }\r\n    // Change the extension?\r\n    if (options.ext) {\r\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\r\n    }\r\n    // Generate destination filename.\r\n    var dest = options.rename(destBase, destPath, options);\r\n    // Prepend cwd to src path if necessary.\r\n    if (options.cwd) { src = path.join(options.cwd, src); }\r\n    // Normalize filepaths to be unix-style.\r\n    dest = dest.replace(pathSeparatorRe, '/');\r\n    src = src.replace(pathSeparatorRe, '/');\r\n    // Map correct src path to dest path.\r\n    if (fileByDest[dest]) {\r\n      // If dest already exists, push this src onto that dest's src array.\r\n      fileByDest[dest].src.push(src);\r\n    } else {\r\n      // Otherwise create a new src-dest file mapping object.\r\n      files.push({\r\n        src: [src],\r\n        dest: dest,\r\n      });\r\n      // And store a reference for later use.\r\n      fileByDest[dest] = files[files.length - 1];\r\n    }\r\n  });\r\n  return files;\r\n};\r\n\r\n// reusing bits of grunt's multi-task source normalization\r\nfile.normalizeFilesArray = function(data) {\r\n  var files = [];\r\n\r\n  data.forEach(function(obj) {\r\n    var prop;\r\n    if ('src' in obj || 'dest' in obj) {\r\n      files.push(obj);\r\n    }\r\n  });\r\n\r\n  if (files.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  files = _(files).chain().forEach(function(obj) {\r\n    if (!('src' in obj) || !obj.src) { return; }\r\n    // Normalize .src properties to flattened array.\r\n    if (Array.isArray(obj.src)) {\r\n      obj.src = flatten(obj.src);\r\n    } else {\r\n      obj.src = [obj.src];\r\n    }\r\n  }).map(function(obj) {\r\n    // Build options object, removing unwanted properties.\r\n    var expandOptions = Object.assign({}, obj);\r\n    delete expandOptions.src;\r\n    delete expandOptions.dest;\r\n\r\n    // Expand file mappings.\r\n    if (obj.expand) {\r\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\r\n        // Copy obj properties to result.\r\n        var result = Object.assign({}, obj);\r\n        // Make a clone of the orig obj available.\r\n        result.orig = Object.assign({}, obj);\r\n        // Set .src and .dest, processing both as templates.\r\n        result.src = mapObj.src;\r\n        result.dest = mapObj.dest;\r\n        // Remove unwanted properties.\r\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\r\n          delete result[prop];\r\n        });\r\n        return result;\r\n      });\r\n    }\r\n\r\n    // Copy obj properties to result, adding an .orig property.\r\n    var result = Object.assign({}, obj);\r\n    // Make a clone of the orig obj available.\r\n    result.orig = Object.assign({}, obj);\r\n\r\n    if ('src' in result) {\r\n      // Expose an expand-on-demand getter method as .src.\r\n      Object.defineProperty(result, 'src', {\r\n        enumerable: true,\r\n        get: function fn() {\r\n          var src;\r\n          if (!('result' in fn)) {\r\n            src = obj.src;\r\n            // If src is an array, flatten it. Otherwise, make it into an array.\r\n            src = Array.isArray(src) ? flatten(src) : [src];\r\n            // Expand src files, memoizing result.\r\n            fn.result = file.expand(expandOptions, src);\r\n          }\r\n          return fn.result;\r\n        }\r\n      });\r\n    }\r\n\r\n    if ('dest' in result) {\r\n      result.dest = obj.dest;\r\n    }\r\n\r\n    return result;\r\n  }).flatten().value();\r\n\r\n  return files;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsMEdBQWE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDRHQUFnQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxxSEFBbUI7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLHNHQUFjO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLDhIQUFzQjtBQUNsRDtBQUNBLFdBQVcsbUJBQU8sQ0FBQyw2RUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLXF1YWxpdHktYW5hbHlzaXMtYXBwLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2FyY2hpdmVyLXV0aWxzQDIuMS4wL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9maWxlLmpzPzVjZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIGFyY2hpdmVyLXV0aWxzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFRhbGtpbmd0b24sIGNvbnRyaWJ1dG9ycy5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLWFyY2hpdmVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UtTUlUXHJcbiAqL1xyXG52YXIgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoLmZsYXR0ZW4nKTtcclxudmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGlmZmVyZW5jZScpO1xyXG52YXIgdW5pb24gPSByZXF1aXJlKCdsb2Rhc2gudW5pb24nKTtcclxudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2guaXNwbGFpbm9iamVjdCcpO1xyXG5cclxudmFyIGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XHJcblxyXG52YXIgZmlsZSA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG52YXIgcGF0aFNlcGFyYXRvclJlID0gL1tcXC9cXFxcXS9nO1xyXG5cclxuLy8gUHJvY2VzcyBzcGVjaWZpZWQgd2lsZGNhcmQgZ2xvYiBwYXR0ZXJucyBvciBmaWxlbmFtZXMgYWdhaW5zdCBhXHJcbi8vIGNhbGxiYWNrLCBleGNsdWRpbmcgYW5kIHVuaXF1aW5nIGZpbGVzIGluIHRoZSByZXN1bHQgc2V0LlxyXG52YXIgcHJvY2Vzc1BhdHRlcm5zID0gZnVuY3Rpb24ocGF0dGVybnMsIGZuKSB7XHJcbiAgLy8gRmlsZXBhdGhzIHRvIHJldHVybi5cclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgLy8gSXRlcmF0ZSBvdmVyIGZsYXR0ZW5lZCBwYXR0ZXJucyBhcnJheS5cclxuICBmbGF0dGVuKHBhdHRlcm5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBhdHRlcm4pIHtcclxuICAgIC8vIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgISBpdCBzaG91bGQgYmUgb21pdHRlZFxyXG4gICAgdmFyIGV4Y2x1c2lvbiA9IHBhdHRlcm4uaW5kZXhPZignIScpID09PSAwO1xyXG4gICAgLy8gSWYgdGhlIHBhdHRlcm4gaXMgYW4gZXhjbHVzaW9uLCByZW1vdmUgdGhlICFcclxuICAgIGlmIChleGNsdXNpb24pIHsgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7IH1cclxuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIGZpbGVzIGZvciB0aGlzIHBhdHRlcm4uXHJcbiAgICB2YXIgbWF0Y2hlcyA9IGZuKHBhdHRlcm4pO1xyXG4gICAgaWYgKGV4Y2x1c2lvbikge1xyXG4gICAgICAvLyBJZiBhbiBleGNsdXNpb24sIHJlbW92ZSBtYXRjaGluZyBmaWxlcy5cclxuICAgICAgcmVzdWx0ID0gZGlmZmVyZW5jZShyZXN1bHQsIG1hdGNoZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBtYXRjaGluZyBmaWxlcy5cclxuICAgICAgcmVzdWx0ID0gdW5pb24ocmVzdWx0LCBtYXRjaGVzKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLy8gVHJ1ZSBpZiB0aGUgZmlsZSBwYXRoIGV4aXN0cy5cclxuZmlsZS5leGlzdHMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZmlsZXBhdGggPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcclxuICByZXR1cm4gZnMuZXhpc3RzU3luYyhmaWxlcGF0aCk7XHJcbn07XHJcblxyXG4vLyBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIGZpbGUgcGF0aHMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gd2lsZGNhcmQgcGF0dGVybnMuXHJcbmZpbGUuZXhwYW5kID0gZnVuY3Rpb24oLi4uYXJncykge1xyXG4gIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25zIG9iamVjdCwgc2F2ZSB0aG9zZSBvcHRpb25zIHRvIHBhc3NcclxuICAvLyBpbnRvIHRoZSBGaWxlLnByb3RvdHlwZS5nbG9iLnN5bmMgbWV0aG9kLlxyXG4gIHZhciBvcHRpb25zID0gaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGFyZ3Muc2hpZnQoKSA6IHt9O1xyXG4gIC8vIFVzZSB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyBhbiBBcnJheSwgb3RoZXJ3aXNlIGNvbnZlcnQgdGhlIGFyZ3VtZW50c1xyXG4gIC8vIG9iamVjdCB0byBhbiBhcnJheSBhbmQgdXNlIHRoYXQuXHJcbiAgdmFyIHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xyXG4gIC8vIFJldHVybiBlbXB0eSBzZXQgaWYgdGhlcmUgYXJlIG5vIHBhdHRlcm5zIG9yIGZpbGVwYXRocy5cclxuICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwKSB7IHJldHVybiBbXTsgfVxyXG4gIC8vIFJldHVybiBhbGwgbWF0Y2hpbmcgZmlsZXBhdGhzLlxyXG4gIHZhciBtYXRjaGVzID0gcHJvY2Vzc1BhdHRlcm5zKHBhdHRlcm5zLCBmdW5jdGlvbihwYXR0ZXJuKSB7XHJcbiAgICAvLyBGaW5kIGFsbCBtYXRjaGluZyBmaWxlcyBmb3IgdGhpcyBwYXR0ZXJuLlxyXG4gICAgcmV0dXJuIGdsb2Iuc3luYyhwYXR0ZXJuLCBvcHRpb25zKTtcclxuICB9KTtcclxuICAvLyBGaWx0ZXIgcmVzdWx0IHNldD9cclxuICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcclxuICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihmdW5jdGlvbihmaWxlcGF0aCkge1xyXG4gICAgICBmaWxlcGF0aCA9IHBhdGguam9pbihvcHRpb25zLmN3ZCB8fCAnJywgZmlsZXBhdGgpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmZpbHRlcihmaWxlcGF0aCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBmaWxlIGlzIG9mIHRoZSByaWdodCB0eXBlIGFuZCBleGlzdHMsIHRoaXMgc2hvdWxkIHdvcmsuXHJcbiAgICAgICAgICByZXR1cm4gZnMuc3RhdFN5bmMoZmlsZXBhdGgpW29wdGlvbnMuZmlsdGVyXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIHByb2JhYmx5IG5vdCB0aGUgcmlnaHQgdHlwZS5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbWF0Y2hlcztcclxufTtcclxuXHJcbi8vIEJ1aWxkIGEgbXVsdGkgdGFzayBcImZpbGVzXCIgb2JqZWN0IGR5bmFtaWNhbGx5LlxyXG5maWxlLmV4cGFuZE1hcHBpbmcgPSBmdW5jdGlvbihwYXR0ZXJucywgZGVzdEJhc2UsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICByZW5hbWU6IGZ1bmN0aW9uKGRlc3RCYXNlLCBkZXN0UGF0aCkge1xyXG4gICAgICByZXR1cm4gcGF0aC5qb2luKGRlc3RCYXNlIHx8ICcnLCBkZXN0UGF0aCk7XHJcbiAgICB9XHJcbiAgfSwgb3B0aW9ucyk7XHJcbiAgdmFyIGZpbGVzID0gW107XHJcbiAgdmFyIGZpbGVCeURlc3QgPSB7fTtcclxuICAvLyBGaW5kIGFsbCBmaWxlcyBtYXRjaGluZyBwYXR0ZXJuLCB1c2luZyBwYXNzZWQtaW4gb3B0aW9ucy5cclxuICBmaWxlLmV4cGFuZChvcHRpb25zLCBwYXR0ZXJucykuZm9yRWFjaChmdW5jdGlvbihzcmMpIHtcclxuICAgIHZhciBkZXN0UGF0aCA9IHNyYztcclxuICAgIC8vIEZsYXR0ZW4/XHJcbiAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XHJcbiAgICAgIGRlc3RQYXRoID0gcGF0aC5iYXNlbmFtZShkZXN0UGF0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBDaGFuZ2UgdGhlIGV4dGVuc2lvbj9cclxuICAgIGlmIChvcHRpb25zLmV4dCkge1xyXG4gICAgICBkZXN0UGF0aCA9IGRlc3RQYXRoLnJlcGxhY2UoLyhcXC5bXlxcL10qKT8kLywgb3B0aW9ucy5leHQpO1xyXG4gICAgfVxyXG4gICAgLy8gR2VuZXJhdGUgZGVzdGluYXRpb24gZmlsZW5hbWUuXHJcbiAgICB2YXIgZGVzdCA9IG9wdGlvbnMucmVuYW1lKGRlc3RCYXNlLCBkZXN0UGF0aCwgb3B0aW9ucyk7XHJcbiAgICAvLyBQcmVwZW5kIGN3ZCB0byBzcmMgcGF0aCBpZiBuZWNlc3NhcnkuXHJcbiAgICBpZiAob3B0aW9ucy5jd2QpIHsgc3JjID0gcGF0aC5qb2luKG9wdGlvbnMuY3dkLCBzcmMpOyB9XHJcbiAgICAvLyBOb3JtYWxpemUgZmlsZXBhdGhzIHRvIGJlIHVuaXgtc3R5bGUuXHJcbiAgICBkZXN0ID0gZGVzdC5yZXBsYWNlKHBhdGhTZXBhcmF0b3JSZSwgJy8nKTtcclxuICAgIHNyYyA9IHNyYy5yZXBsYWNlKHBhdGhTZXBhcmF0b3JSZSwgJy8nKTtcclxuICAgIC8vIE1hcCBjb3JyZWN0IHNyYyBwYXRoIHRvIGRlc3QgcGF0aC5cclxuICAgIGlmIChmaWxlQnlEZXN0W2Rlc3RdKSB7XHJcbiAgICAgIC8vIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsIHB1c2ggdGhpcyBzcmMgb250byB0aGF0IGRlc3QncyBzcmMgYXJyYXkuXHJcbiAgICAgIGZpbGVCeURlc3RbZGVzdF0uc3JjLnB1c2goc3JjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgc3JjLWRlc3QgZmlsZSBtYXBwaW5nIG9iamVjdC5cclxuICAgICAgZmlsZXMucHVzaCh7XHJcbiAgICAgICAgc3JjOiBbc3JjXSxcclxuICAgICAgICBkZXN0OiBkZXN0LFxyXG4gICAgICB9KTtcclxuICAgICAgLy8gQW5kIHN0b3JlIGEgcmVmZXJlbmNlIGZvciBsYXRlciB1c2UuXHJcbiAgICAgIGZpbGVCeURlc3RbZGVzdF0gPSBmaWxlc1tmaWxlcy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZmlsZXM7XHJcbn07XHJcblxyXG4vLyByZXVzaW5nIGJpdHMgb2YgZ3J1bnQncyBtdWx0aS10YXNrIHNvdXJjZSBub3JtYWxpemF0aW9uXHJcbmZpbGUubm9ybWFsaXplRmlsZXNBcnJheSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICB2YXIgZmlsZXMgPSBbXTtcclxuXHJcbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIHByb3A7XHJcbiAgICBpZiAoJ3NyYycgaW4gb2JqIHx8ICdkZXN0JyBpbiBvYmopIHtcclxuICAgICAgZmlsZXMucHVzaChvYmopO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBmaWxlcyA9IF8oZmlsZXMpLmNoYWluKCkuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghKCdzcmMnIGluIG9iaikgfHwgIW9iai5zcmMpIHsgcmV0dXJuOyB9XHJcbiAgICAvLyBOb3JtYWxpemUgLnNyYyBwcm9wZXJ0aWVzIHRvIGZsYXR0ZW5lZCBhcnJheS5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5zcmMpKSB7XHJcbiAgICAgIG9iai5zcmMgPSBmbGF0dGVuKG9iai5zcmMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb2JqLnNyYyA9IFtvYmouc3JjXTtcclxuICAgIH1cclxuICB9KS5tYXAoZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAvLyBCdWlsZCBvcHRpb25zIG9iamVjdCwgcmVtb3ZpbmcgdW53YW50ZWQgcHJvcGVydGllcy5cclxuICAgIHZhciBleHBhbmRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcclxuICAgIGRlbGV0ZSBleHBhbmRPcHRpb25zLnNyYztcclxuICAgIGRlbGV0ZSBleHBhbmRPcHRpb25zLmRlc3Q7XHJcblxyXG4gICAgLy8gRXhwYW5kIGZpbGUgbWFwcGluZ3MuXHJcbiAgICBpZiAob2JqLmV4cGFuZCkge1xyXG4gICAgICByZXR1cm4gZmlsZS5leHBhbmRNYXBwaW5nKG9iai5zcmMsIG9iai5kZXN0LCBleHBhbmRPcHRpb25zKS5tYXAoZnVuY3Rpb24obWFwT2JqKSB7XHJcbiAgICAgICAgLy8gQ29weSBvYmogcHJvcGVydGllcyB0byByZXN1bHQuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XHJcbiAgICAgICAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBvcmlnIG9iaiBhdmFpbGFibGUuXHJcbiAgICAgICAgcmVzdWx0Lm9yaWcgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xyXG4gICAgICAgIC8vIFNldCAuc3JjIGFuZCAuZGVzdCwgcHJvY2Vzc2luZyBib3RoIGFzIHRlbXBsYXRlcy5cclxuICAgICAgICByZXN1bHQuc3JjID0gbWFwT2JqLnNyYztcclxuICAgICAgICByZXN1bHQuZGVzdCA9IG1hcE9iai5kZXN0O1xyXG4gICAgICAgIC8vIFJlbW92ZSB1bndhbnRlZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIFsnZXhwYW5kJywgJ2N3ZCcsICdmbGF0dGVuJywgJ3JlbmFtZScsICdleHQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbcHJvcF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29weSBvYmogcHJvcGVydGllcyB0byByZXN1bHQsIGFkZGluZyBhbiAub3JpZyBwcm9wZXJ0eS5cclxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xyXG4gICAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBvcmlnIG9iaiBhdmFpbGFibGUuXHJcbiAgICByZXN1bHQub3JpZyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XHJcblxyXG4gICAgaWYgKCdzcmMnIGluIHJlc3VsdCkge1xyXG4gICAgICAvLyBFeHBvc2UgYW4gZXhwYW5kLW9uLWRlbWFuZCBnZXR0ZXIgbWV0aG9kIGFzIC5zcmMuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdzcmMnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGZuKCkge1xyXG4gICAgICAgICAgdmFyIHNyYztcclxuICAgICAgICAgIGlmICghKCdyZXN1bHQnIGluIGZuKSkge1xyXG4gICAgICAgICAgICBzcmMgPSBvYmouc3JjO1xyXG4gICAgICAgICAgICAvLyBJZiBzcmMgaXMgYW4gYXJyYXksIGZsYXR0ZW4gaXQuIE90aGVyd2lzZSwgbWFrZSBpdCBpbnRvIGFuIGFycmF5LlxyXG4gICAgICAgICAgICBzcmMgPSBBcnJheS5pc0FycmF5KHNyYykgPyBmbGF0dGVuKHNyYykgOiBbc3JjXTtcclxuICAgICAgICAgICAgLy8gRXhwYW5kIHNyYyBmaWxlcywgbWVtb2l6aW5nIHJlc3VsdC5cclxuICAgICAgICAgICAgZm4ucmVzdWx0ID0gZmlsZS5leHBhbmQoZXhwYW5kT3B0aW9ucywgc3JjKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmbi5yZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ2Rlc3QnIGluIHJlc3VsdCkge1xyXG4gICAgICByZXN1bHQuZGVzdCA9IG9iai5kZXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSkuZmxhdHRlbigpLnZhbHVlKCk7XHJcblxyXG4gIHJldHVybiBmaWxlcztcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2015 Chris Talkington.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\r\n */\r\nvar fs = __webpack_require__(/*! graceful-fs */ \"(ssr)/./node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar nutil = __webpack_require__(/*! util */ \"util\");\r\nvar lazystream = __webpack_require__(/*! lazystream */ \"(ssr)/./node_modules/.pnpm/lazystream@1.0.1/node_modules/lazystream/lib/lazystream.js\");\r\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(ssr)/./node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js\");\r\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"(ssr)/./node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js\");\r\n\r\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\r\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable.js\").PassThrough);\r\n\r\nvar utils = module.exports = {};\r\nutils.file = __webpack_require__(/*! ./file.js */ \"(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js\");\r\n\r\nfunction assertPath(path) {\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError('Path must be a string. Received ' + nutils.inspect(path));\r\n  }\r\n}\r\n\r\nutils.collectStream = function(source, callback) {\r\n  var collection = [];\r\n  var size = 0;\r\n\r\n  source.on('error', callback);\r\n\r\n  source.on('data', function(chunk) {\r\n    collection.push(chunk);\r\n    size += chunk.length;\r\n  });\r\n\r\n  source.on('end', function() {\r\n    var buf = new Buffer(size);\r\n    var offset = 0;\r\n\r\n    collection.forEach(function(data) {\r\n      data.copy(buf, offset);\r\n      offset += data.length;\r\n    });\r\n\r\n    callback(null, buf);\r\n  });\r\n};\r\n\r\nutils.dateify = function(dateish) {\r\n  dateish = dateish || new Date();\r\n\r\n  if (dateish instanceof Date) {\r\n    dateish = dateish;\r\n  } else if (typeof dateish === 'string') {\r\n    dateish = new Date(dateish);\r\n  } else {\r\n    dateish = new Date();\r\n  }\r\n\r\n  return dateish;\r\n};\r\n\r\n// this is slightly different from lodash version\r\nutils.defaults = function(object, source, guard) {\r\n  var args = arguments;\r\n  args[0] = args[0] || {};\r\n\r\n  return defaults(...args);\r\n};\r\n\r\nutils.isStream = function(source) {\r\n  return source instanceof Stream;\r\n};\r\n\r\nutils.lazyReadStream = function(filepath) {\r\n  return new lazystream.Readable(function() {\r\n    return fs.createReadStream(filepath);\r\n  });\r\n};\r\n\r\nutils.normalizeInputSource = function(source) {\r\n  if (source === null) {\r\n    return new Buffer(0);\r\n  } else if (typeof source === 'string') {\r\n    return new Buffer(source);\r\n  } else if (utils.isStream(source) && !source._readableState) {\r\n    var normalized = new PassThrough();\r\n    source.pipe(normalized);\r\n\r\n    return normalized;\r\n  }\r\n\r\n  return source;\r\n};\r\n\r\nutils.sanitizePath = function(filepath) {\r\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\r\n};\r\n\r\nutils.trailingSlashIt = function(str) {\r\n  return str.slice(-1) !== '/' ? str + '/' : str;\r\n};\r\n\r\nutils.unixifyPath = function(filepath) {\r\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\r\n};\r\n\r\nutils.walkdir = function(dirpath, base, callback) {\r\n  var results = [];\r\n\r\n  if (typeof base === 'function') {\r\n    callback = base;\r\n    base = dirpath;\r\n  }\r\n\r\n  fs.readdir(dirpath, function(err, list) {\r\n    var i = 0;\r\n    var file;\r\n    var filepath;\r\n\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    (function next() {\r\n      file = list[i++];\r\n\r\n      if (!file) {\r\n        return callback(null, results);\r\n      }\r\n\r\n      filepath = path.join(dirpath, file);\r\n\r\n      fs.stat(filepath, function(err, stats) {\r\n        results.push({\r\n          path: filepath,\r\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\r\n          stats: stats\r\n        });\r\n\r\n        if (stats && stats.isDirectory()) {\r\n          utils.walkdir(filepath, base, function(err, res) {\r\n            res.forEach(function(dirEntry) {\r\n              results.push(dirEntry);\r\n            });\r\n            next();\r\n          });\r\n        } else {\r\n          next();\r\n        }\r\n      });\r\n    })();\r\n  });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDBHQUFhO0FBQzlCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsa0JBQU07QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMseUdBQVk7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNEdBQWdCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywrR0FBaUI7QUFDeEM7QUFDQSxhQUFhLG9EQUF3QjtBQUNyQyxrQkFBa0IscUpBQXNDO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0dBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtcXVhbGl0eS1hbmFseXNpcy1hcHAvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzPzU1NDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIGFyY2hpdmVyLXV0aWxzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaHJpcyBUYWxraW5ndG9uLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL2FyY2hpdmVyLXV0aWxzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICovXHJcbnZhciBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJyk7XHJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG52YXIgbnV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcbnZhciBsYXp5c3RyZWFtID0gcmVxdWlyZSgnbGF6eXN0cmVhbScpO1xyXG52YXIgbm9ybWFsaXplUGF0aCA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoJyk7XHJcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJ2xvZGFzaC5kZWZhdWx0cycpO1xyXG5cclxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcclxudmFyIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUGFzc1Rocm91Z2g7XHJcblxyXG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG51dGlscy5maWxlID0gcmVxdWlyZSgnLi9maWxlLmpzJyk7XHJcblxyXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcclxuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBudXRpbHMuaW5zcGVjdChwYXRoKSk7XHJcbiAgfVxyXG59XHJcblxyXG51dGlscy5jb2xsZWN0U3RyZWFtID0gZnVuY3Rpb24oc291cmNlLCBjYWxsYmFjaykge1xyXG4gIHZhciBjb2xsZWN0aW9uID0gW107XHJcbiAgdmFyIHNpemUgPSAwO1xyXG5cclxuICBzb3VyY2Uub24oJ2Vycm9yJywgY2FsbGJhY2spO1xyXG5cclxuICBzb3VyY2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xyXG4gICAgY29sbGVjdGlvbi5wdXNoKGNodW5rKTtcclxuICAgIHNpemUgKz0gY2h1bmsubGVuZ3RoO1xyXG4gIH0pO1xyXG5cclxuICBzb3VyY2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XHJcbiAgICB2YXIgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICBkYXRhLmNvcHkoYnVmLCBvZmZzZXQpO1xyXG4gICAgICBvZmZzZXQgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjYWxsYmFjayhudWxsLCBidWYpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxudXRpbHMuZGF0ZWlmeSA9IGZ1bmN0aW9uKGRhdGVpc2gpIHtcclxuICBkYXRlaXNoID0gZGF0ZWlzaCB8fCBuZXcgRGF0ZSgpO1xyXG5cclxuICBpZiAoZGF0ZWlzaCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgIGRhdGVpc2ggPSBkYXRlaXNoO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGVpc2ggPT09ICdzdHJpbmcnKSB7XHJcbiAgICBkYXRlaXNoID0gbmV3IERhdGUoZGF0ZWlzaCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRhdGVpc2ggPSBuZXcgRGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGVpc2g7XHJcbn07XHJcblxyXG4vLyB0aGlzIGlzIHNsaWdodGx5IGRpZmZlcmVudCBmcm9tIGxvZGFzaCB2ZXJzaW9uXHJcbnV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XHJcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgYXJnc1swXSA9IGFyZ3NbMF0gfHwge307XHJcblxyXG4gIHJldHVybiBkZWZhdWx0cyguLi5hcmdzKTtcclxufTtcclxuXHJcbnV0aWxzLmlzU3RyZWFtID0gZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgcmV0dXJuIHNvdXJjZSBpbnN0YW5jZW9mIFN0cmVhbTtcclxufTtcclxuXHJcbnV0aWxzLmxhenlSZWFkU3RyZWFtID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcclxuICByZXR1cm4gbmV3IGxhenlzdHJlYW0uUmVhZGFibGUoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlcGF0aCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG51dGlscy5ub3JtYWxpemVJbnB1dFNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gIGlmIChzb3VyY2UgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBuZXcgQnVmZmVyKHNvdXJjZSk7XHJcbiAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmVhbShzb3VyY2UpICYmICFzb3VyY2UuX3JlYWRhYmxlU3RhdGUpIHtcclxuICAgIHZhciBub3JtYWxpemVkID0gbmV3IFBhc3NUaHJvdWdoKCk7XHJcbiAgICBzb3VyY2UucGlwZShub3JtYWxpemVkKTtcclxuXHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcblxyXG4gIHJldHVybiBzb3VyY2U7XHJcbn07XHJcblxyXG51dGlscy5zYW5pdGl6ZVBhdGggPSBmdW5jdGlvbihmaWxlcGF0aCkge1xyXG4gIHJldHVybiBub3JtYWxpemVQYXRoKGZpbGVwYXRoLCBmYWxzZSkucmVwbGFjZSgvXlxcdys6LywgJycpLnJlcGxhY2UoL14oXFwuXFwuXFwvfFxcLykrLywgJycpO1xyXG59O1xyXG5cclxudXRpbHMudHJhaWxpbmdTbGFzaEl0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5zbGljZSgtMSkgIT09ICcvJyA/IHN0ciArICcvJyA6IHN0cjtcclxufTtcclxuXHJcbnV0aWxzLnVuaXhpZnlQYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcclxuICByZXR1cm4gbm9ybWFsaXplUGF0aChmaWxlcGF0aCwgZmFsc2UpLnJlcGxhY2UoL15cXHcrOi8sICcnKTtcclxufTtcclxuXHJcbnV0aWxzLndhbGtkaXIgPSBmdW5jdGlvbihkaXJwYXRoLCBiYXNlLCBjYWxsYmFjaykge1xyXG4gIHZhciByZXN1bHRzID0gW107XHJcblxyXG4gIGlmICh0eXBlb2YgYmFzZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY2FsbGJhY2sgPSBiYXNlO1xyXG4gICAgYmFzZSA9IGRpcnBhdGg7XHJcbiAgfVxyXG5cclxuICBmcy5yZWFkZGlyKGRpcnBhdGgsIGZ1bmN0aW9uKGVyciwgbGlzdCkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGZpbGU7XHJcbiAgICB2YXIgZmlsZXBhdGg7XHJcblxyXG4gICAgaWYgKGVycikge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgIH1cclxuXHJcbiAgICAoZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgICAgZmlsZSA9IGxpc3RbaSsrXTtcclxuXHJcbiAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZmlsZXBhdGggPSBwYXRoLmpvaW4oZGlycGF0aCwgZmlsZSk7XHJcblxyXG4gICAgICBmcy5zdGF0KGZpbGVwYXRoLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxyXG4gICAgICAgICAgcmVsYXRpdmU6IHBhdGgucmVsYXRpdmUoYmFzZSwgZmlsZXBhdGgpLnJlcGxhY2UoL1xcXFwvZywgJy8nKSxcclxuICAgICAgICAgIHN0YXRzOiBzdGF0c1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgdXRpbHMud2Fsa2RpcihmaWxlcGF0aCwgYmFzZSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcclxuICAgICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24oZGlyRW50cnkpIHtcclxuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZGlyRW50cnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmV4dCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSkoKTtcclxuICB9KTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js\n");

/***/ })

};
;