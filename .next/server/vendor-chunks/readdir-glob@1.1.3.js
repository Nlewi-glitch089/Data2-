/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readdir-glob@1.1.3";
exports.ids = ["vendor-chunks/readdir-glob@1.1.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = readdirGlob;\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst { Minimatch } = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js\");\nconst { resolve } = __webpack_require__(/*! path */ \"path\");\n\nfunction readdir(dir, strict) {\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, {withFileTypes: true} ,(err, files) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOTDIR':      // Not a directory\n            if(strict) {\n              reject(err);\n            } else {\n              resolve([]);\n            }\n            break;\n          case 'ENOTSUP':      // Operation not supported\n          case 'ENOENT':       // No such file or directory\n          case 'ENAMETOOLONG': // Filename too long\n          case 'UNKNOWN':\n            resolve([]);\n            break;\n          case 'ELOOP':        // Too many levels of symbolic links\n          default:\n            reject(err);\n            break;\n        }\n      } else {\n        resolve(files);\n      }\n    });\n  });\n}\nfunction stat(file, followSymlinks) {\n  return new Promise((resolve, reject) => {\n    const statFunc = followSymlinks ? fs.stat : fs.lstat;\n    statFunc(file, (err, stats) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOENT':\n            if(followSymlinks) {\n              // Fallback to lstat to handle broken links as files\n              resolve(stat(file, false)); \n            } else {\n              resolve(null);\n            }\n            break;\n          default:\n            resolve(null);\n            break;\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nasync function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {\n  let files = await readdir(path + dir, strict);\n  for(const file of files) {\n    let name = file.name;\n    if(name === undefined) {\n      // undefined file.name means the `withFileTypes` options is not supported by node\n      // we have to call the stat function to know if file is directory or not.\n      name = file;\n      useStat = true;\n    }\n    const filename = dir + '/' + name;\n    const relative = filename.slice(1); // Remove the leading /\n    const absolute = path + '/' + relative;\n    let stats = null;\n    if(useStat || followSymlinks) {\n      stats = await stat(absolute, followSymlinks);\n    }\n    if(!stats && file.name !== undefined) {\n      stats = file;\n    }\n    if(stats === null) {\n      stats = { isDirectory: () => false };\n    }\n\n    if(stats.isDirectory()) {\n      if(!shouldSkip(relative)) {\n        yield {relative, absolute, stats};\n        yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);\n      }\n    } else {\n      yield {relative, absolute, stats};\n    }\n  }\n}\nasync function* explore(path, followSymlinks, useStat, shouldSkip) {\n  yield* exploreWalkAsync('', path, followSymlinks, useStat, shouldSkip, true);\n}\n\n\nfunction readOptions(options) {\n  return {\n    pattern: options.pattern,\n    dot: !!options.dot,\n    noglobstar: !!options.noglobstar,\n    matchBase: !!options.matchBase,\n    nocase: !!options.nocase,\n    ignore: options.ignore,\n    skip: options.skip,\n\n    follow: !!options.follow,\n    stat: !!options.stat,\n    nodir: !!options.nodir,\n    mark: !!options.mark,\n    silent: !!options.silent,\n    absolute: !!options.absolute\n  };\n}\n\nclass ReaddirGlob extends EventEmitter {\n  constructor(cwd, options, cb) {\n    super();\n    if(typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.options = readOptions(options ||Â {});\n  \n    this.matchers = [];\n    if(this.options.pattern) {\n      const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];\n      this.matchers = matchers.map( m =>\n        new Minimatch(m, {\n          dot: this.options.dot,\n          noglobstar:this.options.noglobstar,\n          matchBase:this.options.matchBase,\n          nocase:this.options.nocase\n        })\n      );\n    }\n  \n    this.ignoreMatchers = [];\n    if(this.options.ignore) {\n      const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];\n      this.ignoreMatchers = ignorePatterns.map( ignore =>\n        new Minimatch(ignore, {dot: true})\n      );\n    }\n  \n    this.skipMatchers = [];\n    if(this.options.skip) {\n      const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];\n      this.skipMatchers = skipPatterns.map( skip =>\n        new Minimatch(skip, {dot: true})\n      );\n    }\n\n    this.iterator = explore(resolve(cwd || '.'), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n    this.paused = false;\n    this.inactive = false;\n    this.aborted = false;\n  \n    if(cb) {\n      this._matches = []; \n      this.on('match', match => this._matches.push(this.options.absolute ? match.absolute : match.relative));\n      this.on('error', err => cb(err));\n      this.on('end', () => cb(null, this._matches));\n    }\n\n    setTimeout( () => this._next(), 0);\n  }\n\n  _shouldSkipDirectory(relative) {\n    //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n    return this.skipMatchers.some(m => m.match(relative));\n  }\n\n  _fileMatches(relative, isDirectory) {\n    const file = relative + (isDirectory ? '/' : '');\n    return (this.matchers.length === 0 || this.matchers.some(m => m.match(file)))\n      && !this.ignoreMatchers.some(m => m.match(file))\n      && (!this.options.nodir || !isDirectory);\n  }\n\n  _next() {\n    if(!this.paused && !this.aborted) {\n      this.iterator.next()\n      .then((obj)=> {\n        if(!obj.done) {\n          const isDirectory = obj.value.stats.isDirectory();\n          if(this._fileMatches(obj.value.relative, isDirectory )) {\n            let relative = obj.value.relative;\n            let absolute = obj.value.absolute;\n            if(this.options.mark && isDirectory) {\n              relative += '/';\n              absolute += '/';\n            }\n            if(this.options.stat) {\n              this.emit('match', {relative, absolute, stat:obj.value.stats});\n            } else {\n              this.emit('match', {relative, absolute});\n            }\n          }\n          this._next(this.iterator);\n        } else {\n          this.emit('end');\n        }\n      })\n      .catch((err) => {\n        this.abort();\n        this.emit('error', err);\n        if(!err.code && !this.options.silent) {\n          console.error(err);\n        }\n      });\n    } else {\n      this.inactive = true;\n    }\n  }\n\n  abort() {\n    this.aborted = true;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n    if(this.inactive) {\n      this.inactive = false;\n      this._next();\n    }\n  }\n}\n\n\nfunction readdirGlob(pattern, options, cb) {\n  return new ReaddirGlob(pattern, options, cb);\n}\nreaddirGlob.ReaddirGlob = ReaddirGlob;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGRpci1nbG9iQDEuMS4zL25vZGVfbW9kdWxlcy9yZWFkZGlyLWdsb2IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN6QyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGlHQUFXO0FBQ3pDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWxDO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRSxjQUFjO0FBQ2Qsa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1xdWFsaXR5LWFuYWx5c2lzLWFwcC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkZGlyLWdsb2JAMS4xLjMvbm9kZV9tb2R1bGVzL3JlYWRkaXItZ2xvYi9pbmRleC5qcz83MGM4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVhZGRpckdsb2I7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IHsgTWluaW1hdGNoIH0gPSByZXF1aXJlKCdtaW5pbWF0Y2gnKTtcbmNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiByZWFkZGlyKGRpciwgc3RyaWN0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZGRpcihkaXIsIHt3aXRoRmlsZVR5cGVzOiB0cnVlfSAsKGVyciwgZmlsZXMpID0+IHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSAnRU5PVERJUic6ICAgICAgLy8gTm90IGEgZGlyZWN0b3J5XG4gICAgICAgICAgICBpZihzdHJpY3QpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0VOT1RTVVAnOiAgICAgIC8vIE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgY2FzZSAnRU5PRU5UJzogICAgICAgLy8gTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVxuICAgICAgICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6IC8vIEZpbGVuYW1lIHRvbyBsb25nXG4gICAgICAgICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0VMT09QJzogICAgICAgIC8vIFRvbyBtYW55IGxldmVscyBvZiBzeW1ib2xpYyBsaW5rc1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGZpbGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzdGF0KGZpbGUsIGZvbGxvd1N5bWxpbmtzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3RhdEZ1bmMgPSBmb2xsb3dTeW1saW5rcyA/IGZzLnN0YXQgOiBmcy5sc3RhdDtcbiAgICBzdGF0RnVuYyhmaWxlLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICAgICAgaWYoZm9sbG93U3ltbGlua3MpIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gbHN0YXQgdG8gaGFuZGxlIGJyb2tlbiBsaW5rcyBhcyBmaWxlc1xuICAgICAgICAgICAgICByZXNvbHZlKHN0YXQoZmlsZSwgZmFsc2UpKTsgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShzdGF0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiogZXhwbG9yZVdhbGtBc3luYyhkaXIsIHBhdGgsIGZvbGxvd1N5bWxpbmtzLCB1c2VTdGF0LCBzaG91bGRTa2lwLCBzdHJpY3QpIHtcbiAgbGV0IGZpbGVzID0gYXdhaXQgcmVhZGRpcihwYXRoICsgZGlyLCBzdHJpY3QpO1xuICBmb3IoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGxldCBuYW1lID0gZmlsZS5uYW1lO1xuICAgIGlmKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdW5kZWZpbmVkIGZpbGUubmFtZSBtZWFucyB0aGUgYHdpdGhGaWxlVHlwZXNgIG9wdGlvbnMgaXMgbm90IHN1cHBvcnRlZCBieSBub2RlXG4gICAgICAvLyB3ZSBoYXZlIHRvIGNhbGwgdGhlIHN0YXQgZnVuY3Rpb24gdG8ga25vdyBpZiBmaWxlIGlzIGRpcmVjdG9yeSBvciBub3QuXG4gICAgICBuYW1lID0gZmlsZTtcbiAgICAgIHVzZVN0YXQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmaWxlbmFtZSA9IGRpciArICcvJyArIG5hbWU7XG4gICAgY29uc3QgcmVsYXRpdmUgPSBmaWxlbmFtZS5zbGljZSgxKTsgLy8gUmVtb3ZlIHRoZSBsZWFkaW5nIC9cbiAgICBjb25zdCBhYnNvbHV0ZSA9IHBhdGggKyAnLycgKyByZWxhdGl2ZTtcbiAgICBsZXQgc3RhdHMgPSBudWxsO1xuICAgIGlmKHVzZVN0YXQgfHwgZm9sbG93U3ltbGlua3MpIHtcbiAgICAgIHN0YXRzID0gYXdhaXQgc3RhdChhYnNvbHV0ZSwgZm9sbG93U3ltbGlua3MpO1xuICAgIH1cbiAgICBpZighc3RhdHMgJiYgZmlsZS5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRzID0gZmlsZTtcbiAgICB9XG4gICAgaWYoc3RhdHMgPT09IG51bGwpIHtcbiAgICAgIHN0YXRzID0geyBpc0RpcmVjdG9yeTogKCkgPT4gZmFsc2UgfTtcbiAgICB9XG5cbiAgICBpZihzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBpZighc2hvdWxkU2tpcChyZWxhdGl2ZSkpIHtcbiAgICAgICAgeWllbGQge3JlbGF0aXZlLCBhYnNvbHV0ZSwgc3RhdHN9O1xuICAgICAgICB5aWVsZCogZXhwbG9yZVdhbGtBc3luYyhmaWxlbmFtZSwgcGF0aCwgZm9sbG93U3ltbGlua3MsIHVzZVN0YXQsIHNob3VsZFNraXAsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQge3JlbGF0aXZlLCBhYnNvbHV0ZSwgc3RhdHN9O1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24qIGV4cGxvcmUocGF0aCwgZm9sbG93U3ltbGlua3MsIHVzZVN0YXQsIHNob3VsZFNraXApIHtcbiAgeWllbGQqIGV4cGxvcmVXYWxrQXN5bmMoJycsIHBhdGgsIGZvbGxvd1N5bWxpbmtzLCB1c2VTdGF0LCBzaG91bGRTa2lwLCB0cnVlKTtcbn1cblxuXG5mdW5jdGlvbiByZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogb3B0aW9ucy5wYXR0ZXJuLFxuICAgIGRvdDogISFvcHRpb25zLmRvdCxcbiAgICBub2dsb2JzdGFyOiAhIW9wdGlvbnMubm9nbG9ic3RhcixcbiAgICBtYXRjaEJhc2U6ICEhb3B0aW9ucy5tYXRjaEJhc2UsXG4gICAgbm9jYXNlOiAhIW9wdGlvbnMubm9jYXNlLFxuICAgIGlnbm9yZTogb3B0aW9ucy5pZ25vcmUsXG4gICAgc2tpcDogb3B0aW9ucy5za2lwLFxuXG4gICAgZm9sbG93OiAhIW9wdGlvbnMuZm9sbG93LFxuICAgIHN0YXQ6ICEhb3B0aW9ucy5zdGF0LFxuICAgIG5vZGlyOiAhIW9wdGlvbnMubm9kaXIsXG4gICAgbWFyazogISFvcHRpb25zLm1hcmssXG4gICAgc2lsZW50OiAhIW9wdGlvbnMuc2lsZW50LFxuICAgIGFic29sdXRlOiAhIW9wdGlvbnMuYWJzb2x1dGVcbiAgfTtcbn1cblxuY2xhc3MgUmVhZGRpckdsb2IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjd2QsIG9wdGlvbnMsIGNiKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gcmVhZE9wdGlvbnMob3B0aW9ucyB8fMKge30pO1xuICBcbiAgICB0aGlzLm1hdGNoZXJzID0gW107XG4gICAgaWYodGhpcy5vcHRpb25zLnBhdHRlcm4pIHtcbiAgICAgIGNvbnN0IG1hdGNoZXJzID0gQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucGF0dGVybikgPyB0aGlzLm9wdGlvbnMucGF0dGVybiA6IFt0aGlzLm9wdGlvbnMucGF0dGVybl07XG4gICAgICB0aGlzLm1hdGNoZXJzID0gbWF0Y2hlcnMubWFwKCBtID0+XG4gICAgICAgIG5ldyBNaW5pbWF0Y2gobSwge1xuICAgICAgICAgIGRvdDogdGhpcy5vcHRpb25zLmRvdCxcbiAgICAgICAgICBub2dsb2JzdGFyOnRoaXMub3B0aW9ucy5ub2dsb2JzdGFyLFxuICAgICAgICAgIG1hdGNoQmFzZTp0aGlzLm9wdGlvbnMubWF0Y2hCYXNlLFxuICAgICAgICAgIG5vY2FzZTp0aGlzLm9wdGlvbnMubm9jYXNlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgXG4gICAgdGhpcy5pZ25vcmVNYXRjaGVycyA9IFtdO1xuICAgIGlmKHRoaXMub3B0aW9ucy5pZ25vcmUpIHtcbiAgICAgIGNvbnN0IGlnbm9yZVBhdHRlcm5zID0gQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuaWdub3JlKSA/IHRoaXMub3B0aW9ucy5pZ25vcmUgOiBbdGhpcy5vcHRpb25zLmlnbm9yZV07XG4gICAgICB0aGlzLmlnbm9yZU1hdGNoZXJzID0gaWdub3JlUGF0dGVybnMubWFwKCBpZ25vcmUgPT5cbiAgICAgICAgbmV3IE1pbmltYXRjaChpZ25vcmUsIHtkb3Q6IHRydWV9KVxuICAgICAgKTtcbiAgICB9XG4gIFxuICAgIHRoaXMuc2tpcE1hdGNoZXJzID0gW107XG4gICAgaWYodGhpcy5vcHRpb25zLnNraXApIHtcbiAgICAgIGNvbnN0IHNraXBQYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnNraXApID8gdGhpcy5vcHRpb25zLnNraXAgOiBbdGhpcy5vcHRpb25zLnNraXBdO1xuICAgICAgdGhpcy5za2lwTWF0Y2hlcnMgPSBza2lwUGF0dGVybnMubWFwKCBza2lwID0+XG4gICAgICAgIG5ldyBNaW5pbWF0Y2goc2tpcCwge2RvdDogdHJ1ZX0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuaXRlcmF0b3IgPSBleHBsb3JlKHJlc29sdmUoY3dkIHx8ICcuJyksIHRoaXMub3B0aW9ucy5mb2xsb3csIHRoaXMub3B0aW9ucy5zdGF0LCB0aGlzLl9zaG91bGRTa2lwRGlyZWN0b3J5LmJpbmQodGhpcykpO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICBcbiAgICBpZihjYikge1xuICAgICAgdGhpcy5fbWF0Y2hlcyA9IFtdOyBcbiAgICAgIHRoaXMub24oJ21hdGNoJywgbWF0Y2ggPT4gdGhpcy5fbWF0Y2hlcy5wdXNoKHRoaXMub3B0aW9ucy5hYnNvbHV0ZSA/IG1hdGNoLmFic29sdXRlIDogbWF0Y2gucmVsYXRpdmUpKTtcbiAgICAgIHRoaXMub24oJ2Vycm9yJywgZXJyID0+IGNiKGVycikpO1xuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gY2IobnVsbCwgdGhpcy5fbWF0Y2hlcykpO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoICgpID0+IHRoaXMuX25leHQoKSwgMCk7XG4gIH1cblxuICBfc2hvdWxkU2tpcERpcmVjdG9yeShyZWxhdGl2ZSkge1xuICAgIC8vY29uc29sZS5sb2cocmVsYXRpdmUsIHRoaXMuc2tpcE1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKHJlbGF0aXZlKSkpO1xuICAgIHJldHVybiB0aGlzLnNraXBNYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChyZWxhdGl2ZSkpO1xuICB9XG5cbiAgX2ZpbGVNYXRjaGVzKHJlbGF0aXZlLCBpc0RpcmVjdG9yeSkge1xuICAgIGNvbnN0IGZpbGUgPSByZWxhdGl2ZSArIChpc0RpcmVjdG9yeSA/ICcvJyA6ICcnKTtcbiAgICByZXR1cm4gKHRoaXMubWF0Y2hlcnMubGVuZ3RoID09PSAwIHx8IHRoaXMubWF0Y2hlcnMuc29tZShtID0+IG0ubWF0Y2goZmlsZSkpKVxuICAgICAgJiYgIXRoaXMuaWdub3JlTWF0Y2hlcnMuc29tZShtID0+IG0ubWF0Y2goZmlsZSkpXG4gICAgICAmJiAoIXRoaXMub3B0aW9ucy5ub2RpciB8fCAhaXNEaXJlY3RvcnkpO1xuICB9XG5cbiAgX25leHQoKSB7XG4gICAgaWYoIXRoaXMucGF1c2VkICYmICF0aGlzLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMuaXRlcmF0b3IubmV4dCgpXG4gICAgICAudGhlbigob2JqKT0+IHtcbiAgICAgICAgaWYoIW9iai5kb25lKSB7XG4gICAgICAgICAgY29uc3QgaXNEaXJlY3RvcnkgPSBvYmoudmFsdWUuc3RhdHMuaXNEaXJlY3RvcnkoKTtcbiAgICAgICAgICBpZih0aGlzLl9maWxlTWF0Y2hlcyhvYmoudmFsdWUucmVsYXRpdmUsIGlzRGlyZWN0b3J5ICkpIHtcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZSA9IG9iai52YWx1ZS5yZWxhdGl2ZTtcbiAgICAgICAgICAgIGxldCBhYnNvbHV0ZSA9IG9iai52YWx1ZS5hYnNvbHV0ZTtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5tYXJrICYmIGlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgIHJlbGF0aXZlICs9ICcvJztcbiAgICAgICAgICAgICAgYWJzb2x1dGUgKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnN0YXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtYXRjaCcsIHtyZWxhdGl2ZSwgYWJzb2x1dGUsIHN0YXQ6b2JqLnZhbHVlLnN0YXRzfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21hdGNoJywge3JlbGF0aXZlLCBhYnNvbHV0ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9uZXh0KHRoaXMuaXRlcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBpZighZXJyLmNvZGUgJiYgIXRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBhYm9ydCgpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pbmFjdGl2ZSkge1xuICAgICAgdGhpcy5pbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRkaXJHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIHJldHVybiBuZXcgUmVhZGRpckdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpO1xufVxucmVhZGRpckdsb2IuUmVhZGRpckdsb2IgPSBSZWFkZGlyR2xvYjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js\n");

/***/ })

};
;